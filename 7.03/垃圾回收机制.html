<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
    <script>
        // 面试题
        // js的垃圾回收机制：针对内存
        // 什么样的数据是没用的数据，没用的数据被销毁时销毁的是堆中的数据
        
        // 内存中分栈和堆。栈是系统创建，堆是程序员创建。如果不能合理的分配使用内存，会导致内存泄漏
        
        // 内存的生命周期
        // 1.分配你所需要的内存
        // 2.使用配置你所需要的内存(读，写)  用空间：存、取
        // 3.不需要的时候将其释放，计算机会将很久不用的东西清空
        
        // 注意：在js高级语言中，只有使用分配所需要内存

        // 垃圾回收算法主要依赖于引用的概念
        // 引用分类：显示引用 隐式引用
        // 1.显示引用：一个对象访问另一个对象下的属性
        // 2.隐式引用：一个对象通过原型对象访问的属性

        // 对象：GO AO 函数对象 普通对象
        

        // 引用计数垃圾收集
        // 关键看一个对象是否被其他对象引用
        // 没有被其他对象引用的对象称为零引用，零引用的对象被垃圾回收机制所回收
        var o = {
            a:{
                b:2
            },
        };
        // 两个对象，一个key为a，一个key为b
        // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
        // 很显然，没有一个可以被垃圾收集
        var o2 = o; // o2变量是第二个对“这个对象”的引用
        o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有
        var oa = o2.a; // 引用“这个对象”的a属性
                    // 现在，“这个对象”有两个引用了，一个是o2，一个是oa
        o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
                // 但是它的属性a的对象还在被oa引用，所以还不能回收
        oa = null; // a属性的那个对象现在也是零引用了
                // 它可以被垃圾回收了


    // 总结：代码从头执行到尾，如果说这个对象以及对象中属性没有被任何全局变量所引用（直接或间接引用），那么对象就会被回收。

    // 循环引用：（学术观点不同）浏览器底层处理原理方式不同，ie67内存泄漏（符合引用计数垃圾算法），其他浏览器用的是循环引用算法和引用计数垃圾算法
    </script>
</html>